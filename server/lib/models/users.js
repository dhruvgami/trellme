// Generated by CoffeeScript 1.6.3
(function() {
  var Boards, GenPassword, ObjectID, Trellos, Users, async, config, dbconnection, _, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = require('underscore');

  async = require('async');

  ObjectID = require('mongodb').ObjectID;

  dbconnection = require('./dbconnection');

  Boards = require('./boards');

  Trellos = require('./trellos');

  GenPassword = require('../helpers/genpassword');

  config = require('../../config/config');

  module.exports = Users = (function(_super) {
    __extends(Users, _super);

    function Users() {
      _ref = Users.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    Users.colName = 'users';

    Users.index('email', {
      unique: true
    });

    Users.index('settings.daily_email');

    Users.index('reset_password_token');

    Users.emailRegexp = /^[a-zA-Z0-9\\.!#$%&'*+\-/=?\^_{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$/;

    Users.userFromMongoDocument = function(error, document, cb) {
      if (document === null) {
        error = new Error('User not found');
      }
      if (error) {
        return cb(error, null);
      } else {
        return cb(null, new Users(document));
      }
    };

    Users.find = function(userId, cb) {
      var _this = this;
      if (typeof userId === 'string') {
        userId = new ObjectID(userId);
      }
      return this.collection(function(err, col) {
        if (err) {
          return cb(err, null);
        }
        return col.findOne({
          _id: userId
        }, function(err, doc) {
          return _this.userFromMongoDocument(err, doc, cb);
        });
      });
    };

    Users.findAll = function(cb) {
      return this.collection(function(err, col) {
        return col.find({}).toArray(cb);
      });
    };

    Users.findByEmail = function(email, cb) {
      var _this = this;
      return this.collection(function(err, col) {
        if (err) {
          return cb(err, null);
        }
        return col.findOne({
          email: email
        }, function(err, doc) {
          return _this.userFromMongoDocument(err, doc, cb);
        });
      });
    };

    Users.findByResetPasswordToken = function(token, cb) {
      var _this = this;
      return this.collection(function(err, col) {
        if (err) {
          return cb(err, null);
        }
        return col.findOne({
          reset_password_token: token
        }, function(err, doc) {
          return _this.userFromMongoDocument(err, doc, cb);
        });
      });
    };

    Users.create = function(params, cb) {
      var _this = this;
      if (params == null) {
        params = {};
      }
      if (!params.email.match(Users.emailRegexp)) {
        return cb(500, "Invalid email address");
      }
      if (!params.trello_username.match(/^[a-zA-Z\\.\-0-9_]+$/)) {
        return cb(500, "Invalid Trello username");
      }
      return this.collection(function(err, col) {
        var values;
        if (err) {
          return cb(500, "Failed to insert a user");
        }
        values = {
          email: params.email,
          trello_username: params.trello_username,
          tzdiff: params.tzdiff,
          password: GenPassword.createHash(params.password),
          created: new Date(),
          settings: {
            daily_email: true,
            manual_sync: false
          }
        };
        return col.insert(values, {
          safe: true
        }, function(err, doc) {
          if (err) {
            return cb(err, null);
          } else {
            return cb(null, new Users(doc[0]));
          }
        });
      });
    };

    Users.remove = function(userId, cb) {
      if (typeof userId === 'string') {
        userId = new ObjectID(userId);
      }
      return this.collection(function(err, col) {
        if (err) {
          return cb(err, null);
        }
        return col.remove({
          _id: userId
        }, cb);
      });
    };

    Users.subscribedUsers = function(cb) {
      return this.collection(function(err, col) {
        if (err) {
          return cb(err, null);
        }
        return col.find({
          'settings.daily_email': true
        }).toArray(cb);
      });
    };

    Users.serialize = function(user, done) {
      return done(null, user._id);
    };

    Users.deserialize = function(id, done) {
      return Users.find(id, done);
    };

    Users.prototype.toJSON = function() {
      return {
        _id: this._id,
        email: this.email,
        access_token: this.access_token,
        trello_username: this.trello_username,
        settings: this.settings,
        reset_password_token: this.reset_password_token
      };
    };

    Users.prototype.save = function(values, cb) {
      var _this = this;
      if (!this._id) {
        return cb(new Error('Document id not present'));
      }
      return Users.collection(function(err, col) {
        if (err) {
          return cb(err, null);
        }
        return col.findAndModify({
          _id: _this._id
        }, null, {
          $set: values
        }, {
          "new": true
        }, cb);
      });
    };

    Users.prototype.getBoards = function(cb) {
      return Boards.findByUserId(this._id, cb);
    };

    Users.prototype.getSettings = function(cb) {
      var _this = this;
      return this.getBoards(function(err, boards) {
        var settings;
        if (err) {
          return cb(err, null);
        }
        boards = _(boards).map(function(board) {
          return {
            _id: board._id,
            name: board.boards.name,
            closed: board.boards.closed,
            enabled: board.enabled
          };
        });
        settings = _(_this.settings || {}).extend({
          boards: boards
        });
        return cb(null, settings);
      });
    };

    Users.prototype.saveSettings = function(settings, cb) {
      var userSettings,
        _this = this;
      settings.boards = settings.boards || [];
      userSettings = {
        daily_email: settings.daily_email,
        manual_sync: settings.manual_sync
      };
      return Users.collection(function(err, col) {
        if (err) {
          return cb(err, null);
        }
        return col.findAndModify({
          _id: _this._id
        }, null, {
          $set: {
            settings: userSettings
          }
        }, {
          "new": true
        }, function(err, user) {
          if (err) {
            return cb(err, null);
          }
          return async.each(settings.boards, function(board, asyncCB) {
            return Boards.updateBoard(board._id, {
              enabled: board.enabled
            }, function(err, obj) {
              return asyncCB(err);
            });
          }, function(err) {
            return cb(err, user);
          });
        });
      });
    };

    Users.prototype.verifyPassword = function(password) {
      return GenPassword.validateHash(this.password, password);
    };

    Users.prototype.requestPasswordReset = function(cb) {
      var resetParams, token,
        _this = this;
      token = GenPassword.generateSalt(20);
      resetParams = {
        reset_password_token: token
      };
      return this.save(resetParams, function(err, user) {
        _this.sendPasswordResetInstructionsEmail();
        return cb(err, resetParams);
      });
    };

    Users.prototype.resetPassword = function(password, passwordConfirmation, cb) {
      var values;
      if (_.isEmpty(password)) {
        return cb(new Error("Password can't be blank"), null);
      } else if (password !== passwordConfirmation) {
        return cb(new Error("Password doesn't match confirmation"), null);
      } else {
        values = {
          password: GenPassword.createHash(password),
          reset_password_token: null
        };
        return this.save(values, cb);
      }
    };

    Users.prototype.resetPasswordLink = function() {
      return "http://" + config.api_host + "/password/reset?token=" + this.reset_password_token;
    };

    Users.prototype.sendPasswordResetInstructionsEmail = function(cb) {
      if (cb) {
        return cb();
      }
    };

    Users.prototype.save_token_secret = function(user_id, value, fn) {
      var _this = this;
      return dbconnection.get_client(function(err, p_client) {
        return p_client.collection('users', function(err, col) {
          if (err) {
            return fn(err, null);
          }
          return col.update({
            _id: new ObjectID(user_id)
          }, {
            $set: {
              token_secret: value
            }
          }, function(err) {
            if (err) {
              return fn(err, null);
            } else {
              return fn(null, "update success");
            }
          });
        });
      });
    };

    Users.prototype.save_access_token = function(user_id, values, fn) {
      var _this = this;
      return dbconnection.get_client(function(err, p_client) {
        return p_client.collection('users', function(err, col) {
          if (err) {
            return fn(err, null);
          }
          return col.update({
            _id: new ObjectID(user_id)
          }, {
            $set: values
          }, function(err) {
            if (err) {
              return fn(err, null);
            } else {
              return fn(null, "update success");
            }
          });
        });
      });
    };

    Users.prototype.get = function(userId, fn) {
      var _this = this;
      if (typeof userId === 'string') {
        userId = new ObjectID(userId);
      }
      return dbconnection.get_client(function(err, p_client) {
        return p_client.collection('users', function(err, col) {
          if (err) {
            return fn(err, null);
          }
          return col.findOne({
            _id: userId
          }, function(err, user) {
            return fn(null, user);
          });
        });
      });
    };

    return Users;

  }).call(this, dbconnection);

}).call(this);
